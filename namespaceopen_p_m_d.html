<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>openPMD-api: openPMD Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openPMD-api
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">openPMD Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public definitions of openPMD-api.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_file_position.html">AbstractFilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for communicating between logical and physically persistent data.  <a href="classopen_p_m_d_1_1_abstract_i_o_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl.html">AbstractIOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler_impl_common.html">AbstractIOHandlerImplCommon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_abstract_parameter.html">AbstractParameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_a_d_i_o_s1_file_position.html">ADIOS1FilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler.html">ADIOS1IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s1_i_o_handler_impl.html">ADIOS1IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_a_d_i_o_s2_file_position.html">ADIOS2FilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s2_i_o_handler.html">ADIOS2IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_a_d_i_o_s2_i_o_handler_impl.html">ADIOS2IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_attributable.html">Attributable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer to manage storage of attributes associated with file objects.  <a href="classopen_p_m_d_1_1_attributable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Varidic datatype supporting at least all formats for attributes specified in the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> standard.  <a href="classopen_p_m_d_1_1_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_base_record.html">BaseRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_base_record_component.html">BaseRecordComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_container.html">Container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-like container that enforces <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> requirements and handles IO.  <a href="classopen_p_m_d_1_1_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_dataset.html">Dataset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1decay__equiv.html">decay_equiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental equivalence check for two given types T and U.  <a href="structopen_p_m_d_1_1decay__equiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_do_convert.html">DoConvert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_do_convert_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_u_01_4_00_01false_01_4.html">DoConvert&lt; std::vector&lt; T &gt;, std::vector&lt; U &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_do_convert_3_01_t_00_01_u_00_01false_01_4.html">DoConvert&lt; T, U, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_do_convert_3_01_t_00_01_u_00_01true_01_4.html">DoConvert&lt; T, U, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_dummy_i_o_handler.html">DummyIOHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy handler without any IO operations.  <a href="classopen_p_m_d_1_1_dummy_i_o_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_file.html">File</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_h_d_f5_file_position.html">HDF5FilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler.html">HDF5IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_h_d_f5_i_o_handler_impl.html">HDF5IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_invalidatable_file.html">InvalidatableFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a shared pointer to:  <a href="structopen_p_m_d_1_1_invalidatable_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_i_o_task.html">IOTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-contained description of a single IO operation.  <a href="classopen_p_m_d_1_1_i_o_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_iteration.html">Iteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical compilation of data from one snapshot (e.g.  <a href="classopen_p_m_d_1_1_iteration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_j_s_o_n_file_position.html">JSONFilePosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler.html">JSONIOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_j_s_o_n_i_o_handler_impl.html">JSONIOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopen_p_m_d_1_1_container.html" title="Map-like container that enforces openPMD requirements and handles IO. ">Container</a> for N-dimensional, homogeneous Records.  <a href="classopen_p_m_d_1_1_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_mesh_record_component.html">MeshRecordComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1no__such__attribute__error.html">no_such_attribute_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1no__such__file__error.html">no_such_file_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_parallel_a_d_i_o_s1_i_o_handler.html">ParallelADIOS1IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_parallel_a_d_i_o_s1_i_o_handler_impl.html">ParallelADIOS1IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_parallel_h_d_f5_i_o_handler.html">ParallelHDF5IOHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_parallel_h_d_f5_i_o_handler_impl.html">ParallelHDF5IOHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typesafe description of all required arguments for a specified Operation.  <a href="structopen_p_m_d_1_1_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_c_r_e_a_t_e___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::CREATE_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_c_r_e_a_t_e___f_i_l_e_01_4.html">Parameter&lt; Operation::CREATE_FILE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_c_r_e_a_t_e___p_a_t_h_01_4.html">Parameter&lt; Operation::CREATE_PATH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_d_e_l_e_t_e___a_t_t_01_4.html">Parameter&lt; Operation::DELETE_ATT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_d_e_l_e_t_e___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::DELETE_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_d_e_l_e_t_e___f_i_l_e_01_4.html">Parameter&lt; Operation::DELETE_FILE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_d_e_l_e_t_e___p_a_t_h_01_4.html">Parameter&lt; Operation::DELETE_PATH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_e_x_t_e_n_d___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::EXTEND_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_l_i_s_t___a_t_t_s_01_4.html">Parameter&lt; Operation::LIST_ATTS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_l_i_s_t___d_a_t_a_s_e_t_s_01_4.html">Parameter&lt; Operation::LIST_DATASETS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_l_i_s_t___p_a_t_h_s_01_4.html">Parameter&lt; Operation::LIST_PATHS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_o_p_e_n___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::OPEN_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_o_p_e_n___f_i_l_e_01_4.html">Parameter&lt; Operation::OPEN_FILE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_o_p_e_n___p_a_t_h_01_4.html">Parameter&lt; Operation::OPEN_PATH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_r_e_a_d___a_t_t_01_4.html">Parameter&lt; Operation::READ_ATT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_r_e_a_d___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::READ_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_w_r_i_t_e___a_t_t_01_4.html">Parameter&lt; Operation::WRITE_ATT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen_p_m_d_1_1_parameter_3_01_operation_1_1_w_r_i_t_e___d_a_t_a_s_e_t_01_4.html">Parameter&lt; Operation::WRITE_DATASET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_particle_patches.html">ParticlePatches</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_particle_species.html">ParticleSpecies</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_patch_record.html">PatchRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_patch_record_component.html">PatchRecordComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_record.html">Record</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_record_component.html">RecordComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_series.html">Series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root level of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> hierarchy.  <a href="classopen_p_m_d_1_1_series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1unsupported__data__error.html">unsupported_data_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer to mirror structure of logical data and persistent data in file.  <a href="classopen_p_m_d_1_1_writable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a888344759a4462c331b7d486318d08af"><td class="memItemLeft" align="right" valign="top"><a id="a888344759a4462c331b7d486318d08af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Extent</b> = std::vector&lt; std::uint64_t &gt;</td></tr>
<tr class="separator:a888344759a4462c331b7d486318d08af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de848594ce6120f03f2a664577a4619"><td class="memItemLeft" align="right" valign="top"><a id="a2de848594ce6120f03f2a664577a4619"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Offset</b> = std::vector&lt; std::uint64_t &gt;</td></tr>
<tr class="separator:a2de848594ce6120f03f2a664577a4619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac04f58bb14b584a3685793e5b29ccd00"><td class="memItemLeft" align="right" valign="top"><a id="ac04f58bb14b584a3685793e5b29ccd00"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> : int { <br />
&#160;&#160;<b>CHAR</b> = 0, 
<b>UCHAR</b>, 
<b>SHORT</b>, 
<b>INT</b>, 
<br />
&#160;&#160;<b>LONG</b>, 
<b>LONGLONG</b>, 
<b>USHORT</b>, 
<b>UINT</b>, 
<br />
&#160;&#160;<b>ULONG</b>, 
<b>ULONGLONG</b>, 
<b>FLOAT</b>, 
<b>DOUBLE</b>, 
<br />
&#160;&#160;<b>LONG_DOUBLE</b>, 
<b>STRING</b>, 
<b>VEC_CHAR</b>, 
<b>VEC_SHORT</b>, 
<br />
&#160;&#160;<b>VEC_INT</b>, 
<b>VEC_LONG</b>, 
<b>VEC_LONGLONG</b>, 
<b>VEC_UCHAR</b>, 
<br />
&#160;&#160;<b>VEC_USHORT</b>, 
<b>VEC_UINT</b>, 
<b>VEC_ULONG</b>, 
<b>VEC_ULONGLONG</b>, 
<br />
&#160;&#160;<b>VEC_FLOAT</b>, 
<b>VEC_DOUBLE</b>, 
<b>VEC_LONG_DOUBLE</b>, 
<b>VEC_STRING</b>, 
<br />
&#160;&#160;<b>ARR_DBL_7</b>, 
<b>BOOL</b>, 
<b>DATATYPE</b> = 1000, 
<b>UNDEFINED</b>
<br />
 }<tr class="memdesc:ac04f58bb14b584a3685793e5b29ccd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete datatype of an object available at runtime. <br /></td></tr>
</td></tr>
<tr class="separator:ac04f58bb14b584a3685793e5b29ccd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5e394ac0a898c858a43b60913d46ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46ad">AccessType</a> { <a class="el" href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46ada47c7e7cb36a953a8c47e02000036bb44">AccessType::READ_ONLY</a>, 
<a class="el" href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46adaa7b843fb734e3b3fea8e5f902d3f4144">AccessType::READ_WRITE</a>, 
<a class="el" href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46ada294ce20cdefa29be3be0735cb62e715d">AccessType::CREATE</a>
 }<tr class="memdesc:afe5e394ac0a898c858a43b60913d46ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">File access mode to use during IO.  <a href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46ad">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:afe5e394ac0a898c858a43b60913d46ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc2b05c997920a65ff9297e52f3286d"><td class="memItemLeft" align="right" valign="top"><a id="a7dc2b05c997920a65ff9297e52f3286d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> { <br />
&#160;&#160;<b>HDF5</b>, 
<b>ADIOS1</b>, 
<b>ADIOS2</b>, 
<b>JSON</b>, 
<br />
&#160;&#160;<b>DUMMY</b>
<br />
 }<tr class="memdesc:a7dc2b05c997920a65ff9297e52f3286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">File format to use during IO. <br /></td></tr>
</td></tr>
<tr class="separator:a7dc2b05c997920a65ff9297e52f3286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbaf693665cd3c88561dd406ffadb5c"><td class="memItemLeft" align="right" valign="top"><a id="aebbaf693665cd3c88561dd406ffadb5c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#aebbaf693665cd3c88561dd406ffadb5c">Operation</a> { <br />
&#160;&#160;<b>CREATE_FILE</b>, 
<b>OPEN_FILE</b>, 
<b>DELETE_FILE</b>, 
<b>CREATE_PATH</b>, 
<br />
&#160;&#160;<b>OPEN_PATH</b>, 
<b>DELETE_PATH</b>, 
<b>LIST_PATHS</b>, 
<b>CREATE_DATASET</b>, 
<br />
&#160;&#160;<b>EXTEND_DATASET</b>, 
<b>OPEN_DATASET</b>, 
<b>DELETE_DATASET</b>, 
<b>WRITE_DATASET</b>, 
<br />
&#160;&#160;<b>READ_DATASET</b>, 
<b>LIST_DATASETS</b>, 
<b>DELETE_ATT</b>, 
<b>WRITE_ATT</b>, 
<br />
&#160;&#160;<b>READ_ATT</b>, 
<b>LIST_ATTS</b>
<br />
 }<tr class="memdesc:aebbaf693665cd3c88561dd406ffadb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of IO operation between logical and persistent data. <br /></td></tr>
</td></tr>
<tr class="separator:aebbaf693665cd3c88561dd406ffadb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836aa9398502263fb423787947bf4ff8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a836aa9398502263fb423787947bf4ff8">IterationEncoding</a> { <b>fileBased</b>, 
<b>groupBased</b>
 }<tr class="memdesc:a836aa9398502263fb423787947bf4ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoding scheme of an Iterations Series'.  <a href="namespaceopen_p_m_d.html#a836aa9398502263fb423787947bf4ff8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a836aa9398502263fb423787947bf4ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd35872ff3aaacc1ec2700443d89c40"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40">UnitDimension</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40ad20caec3b48a1eef164cb4ca81ba2587">UnitDimension::L</a> = 0, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40a69691c7bdcc3ce6d5d8a1361f22d04ac">UnitDimension::M</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40ab9ece18c950afbfa6b0fdbfa4ff731d3">UnitDimension::T</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40add7536794b63bf90eccfd37f9b147d7f">UnitDimension::I</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40a61a74be60d291cc4678ab46cc1cdaf91">UnitDimension::theta</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40a8d9c307cb7f3c4a32822a51922d1ceaa">UnitDimension::N</a>, 
<a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40aff44570aca8241914870afbc310cdb85">UnitDimension::J</a>
<br />
 }<tr class="memdesc:a5bd35872ff3aaacc1ec2700443d89c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical dimension of a record.  <a href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a5bd35872ff3aaacc1ec2700443d89c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af20bc44de60df72da1efc5063b8bc87c"><td class="memItemLeft" align="right" valign="top"><a id="af20bc44de60df72da1efc5063b8bc87c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>warnWrongDtype</b> (std::string const &amp;key, <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> store, <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> request)</td></tr>
<tr class="separator:af20bc44de60df72da1efc5063b8bc87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f65f2fbb62d1792cc286ef9946b72d"><td class="memItemLeft" align="right" valign="top"><a id="a55f65f2fbb62d1792cc286ef9946b72d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const &amp;d)</td></tr>
<tr class="separator:a55f65f2fbb62d1792cc286ef9946b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa1009d5cb668e87c84fe1b923c9f97"><td class="memItemLeft" align="right" valign="top"><a id="a5aa1009d5cb668e87c84fe1b923c9f97"></a>
<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stringToDatatype</b> (std::string s)</td></tr>
<tr class="separator:a5aa1009d5cb668e87c84fe1b923c9f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75707f4bc429660e9734e8374ce79d23"><td class="memItemLeft" align="right" valign="top"><a id="a75707f4bc429660e9734e8374ce79d23"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>datatypeToString</b> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> dt)</td></tr>
<tr class="separator:a75707f4bc429660e9734e8374ce79d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed98a0d6afbbfda7c19c6917fc7ab411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#aed98a0d6afbbfda7c19c6917fc7ab411">basicDatatype</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dt)</td></tr>
<tr class="memdesc:aed98a0d6afbbfda7c19c6917fc7ab411"><td class="mdescLeft">&#160;</td><td class="mdescRight">basicDatatype Strip <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> Datatype of std::vector, std::array et.  <a href="#aed98a0d6afbbfda7c19c6917fc7ab411">More...</a><br /></td></tr>
<tr class="separator:aed98a0d6afbbfda7c19c6917fc7ab411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1fe8002d4358804bd49be7a326922e"><td class="memItemLeft" align="right" valign="top"><a id="abb1fe8002d4358804bd49be7a326922e"></a>
<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><b>toVectorType</b> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dt)</td></tr>
<tr class="separator:abb1fe8002d4358804bd49be7a326922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae7debe2cfe5e72fa62c26e265da442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#adae7debe2cfe5e72fa62c26e265da442">determineFormat</a> (std::string const  &amp;filename)</td></tr>
<tr class="memdesc:adae7debe2cfe5e72fa62c26e265da442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the storage format of a <a class="el" href="classopen_p_m_d_1_1_series.html" title="Root level of the openPMD hierarchy. ">Series</a> from the used filename extension.  <a href="#adae7debe2cfe5e72fa62c26e265da442">More...</a><br /></td></tr>
<tr class="separator:adae7debe2cfe5e72fa62c26e265da442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85ac121e561aace5e433173de458068"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#ae85ac121e561aace5e433173de458068">suffix</a> (<a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> f)</td></tr>
<tr class="memdesc:ae85ac121e561aace5e433173de458068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the default filename suffix for a given storage format.  <a href="#ae85ac121e561aace5e433173de458068">More...</a><br /></td></tr>
<tr class="separator:ae85ac121e561aace5e433173de458068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cda7efef783c0accdbf3097ff698c7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a31cda7efef783c0accdbf3097ff698c7">createIOHandler</a> (std::string path, <a class="el" href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46ad">AccessType</a> accessType, <a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> format, MPI_Comm comm)</td></tr>
<tr class="memdesc:a31cda7efef783c0accdbf3097ff698c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an appropriate specific IOHandler for the desired IO mode that may be MPI-aware.  <a href="#a31cda7efef783c0accdbf3097ff698c7">More...</a><br /></td></tr>
<tr class="separator:a31cda7efef783c0accdbf3097ff698c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacd154a6a5324e315942f5d9355a9ee"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#adacd154a6a5324e315942f5d9355a9ee">createIOHandler</a> (std::string path, <a class="el" href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46ad">AccessType</a> accessType, <a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> format)</td></tr>
<tr class="memdesc:adacd154a6a5324e315942f5d9355a9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an appropriate specific IOHandler for the desired IO mode.  <a href="#adacd154a6a5324e315942f5d9355a9ee">More...</a><br /></td></tr>
<tr class="separator:adacd154a6a5324e315942f5d9355a9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e08382d88c84257de703505876b3c03"><td class="memItemLeft" align="right" valign="top"><a id="a4e08382d88c84257de703505876b3c03"></a>
<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getWritable</b> (<a class="el" href="classopen_p_m_d_1_1_attributable.html">Attributable</a> *a)</td></tr>
<tr class="separator:a4e08382d88c84257de703505876b3c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464eb3d415d7da00a7e271968f7aa69c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a464eb3d415d7da00a7e271968f7aa69c">cleanFilename</a> (std::string const &amp;filename, <a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> f)</td></tr>
<tr class="memdesc:a464eb3d415d7da00a7e271968f7aa69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the filename extension of a given storage format.  <a href="#a464eb3d415d7da00a7e271968f7aa69c">More...</a><br /></td></tr>
<tr class="separator:a464eb3d415d7da00a7e271968f7aa69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d9ef7c9f67b687c9e1b4b10f2519f"><td class="memItemLeft" align="right" valign="top">std::function&lt; std::tuple&lt; bool, int &gt;std::string const  &amp;) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#ab71d9ef7c9f67b687c9e1b4b10f2519f">matcher</a> (std::string const &amp;prefix, int padding, std::string const &amp;postfix, <a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> f)</td></tr>
<tr class="memdesc:ab71d9ef7c9f67b687c9e1b4b10f2519f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a functor to determine if a file can be of a format and matches an iterationEncoding, given the filename on disk.  <a href="#ab71d9ef7c9f67b687c9e1b4b10f2519f">More...</a><br /></td></tr>
<tr class="separator:ab71d9ef7c9f67b687c9e1b4b10f2519f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a2ab20d020a17e39a451af889ec9a3"><td class="memItemLeft" align="right" valign="top"><a id="ad1a2ab20d020a17e39a451af889ec9a3"></a>
std::function&lt; std::tuple&lt; bool, int &gt;std::string const  &amp;) &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>buildMatcher</b> (std::string const &amp;regexPattern)</td></tr>
<tr class="separator:ad1a2ab20d020a17e39a451af889ec9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9302b24b95911d3524d0539cf71bcac0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9302b24b95911d3524d0539cf71bcac0"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a9302b24b95911d3524d0539cf71bcac0">getCast</a> (<a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a> const &amp;a)</td></tr>
<tr class="memdesc:a9302b24b95911d3524d0539cf71bcac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a stored specific <a class="el" href="classopen_p_m_d_1_1_attribute.html" title="Varidic datatype supporting at least all formats for attributes specified in the openPMD standard...">Attribute</a> and cast if convertible.  <a href="#a9302b24b95911d3524d0539cf71bcac0">More...</a><br /></td></tr>
<tr class="separator:a9302b24b95911d3524d0539cf71bcac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0acf8ce265548d95417e8fbb0e85e88"><td class="memItemLeft" align="right" valign="top"><a id="ac0acf8ce265548d95417e8fbb0e85e88"></a>
<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dtype_from_numpy</b> (pybind11::dtype const dt)</td></tr>
<tr class="separator:ac0acf8ce265548d95417e8fbb0e85e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8e0b5f39fece9dd2b1e188d897261b"><td class="memItemLeft" align="right" valign="top"><a id="abc8e0b5f39fece9dd2b1e188d897261b"></a>
<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#abc8e0b5f39fece9dd2b1e188d897261b">dtype_from_bufferformat</a> (std::string const &amp;fmt)</td></tr>
<tr class="memdesc:abc8e0b5f39fece9dd2b1e188d897261b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00" title="Concrete datatype of an object available at runtime. ">openPMD::Datatype</a> from py::buffer_info::format. <br /></td></tr>
<tr class="separator:abc8e0b5f39fece9dd2b1e188d897261b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ccdac508e96668e0335bb09ae72dd7"><td class="memItemLeft" align="right" valign="top"><a id="a81ccdac508e96668e0335bb09ae72dd7"></a>
pybind11::dtype&#160;</td><td class="memItemRight" valign="bottom"><b>dtype_to_numpy</b> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> const dt)</td></tr>
<tr class="separator:a81ccdac508e96668e0335bb09ae72dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609f7e0dfe97f627fe345c2e8c7159c8"><td class="memTemplParams" colspan="2"><a id="a609f7e0dfe97f627fe345c2e8c7159c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a609f7e0dfe97f627fe345c2e8c7159c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>determineDatatype</b> ()</td></tr>
<tr class="separator:a609f7e0dfe97f627fe345c2e8c7159c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f16406500f1166abf3d40e981668ee"><td class="memTemplParams" colspan="2"><a id="a86f16406500f1166abf3d40e981668ee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86f16406500f1166abf3d40e981668ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>determineDatatype</b> (std::shared_ptr&lt; T &gt;)</td></tr>
<tr class="separator:a86f16406500f1166abf3d40e981668ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b670ad71d6e80073a7d8fb689b1fd4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a9b670ad71d6e80073a7d8fb689b1fd4a">toBytes</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a9b670ad71d6e80073a7d8fb689b1fd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes representing a Datatype.  <a href="#a9b670ad71d6e80073a7d8fb689b1fd4a">More...</a><br /></td></tr>
<tr class="separator:a9b670ad71d6e80073a7d8fb689b1fd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ccc9b338d37af8c6bbbcf4f53dfeee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a31ccc9b338d37af8c6bbbcf4f53dfeee">toBits</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a31ccc9b338d37af8c6bbbcf4f53dfeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bits representing a Datatype.  <a href="#a31ccc9b338d37af8c6bbbcf4f53dfeee">More...</a><br /></td></tr>
<tr class="separator:a31ccc9b338d37af8c6bbbcf4f53dfeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba5e10b9852d6f900b1998d974fef04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a1ba5e10b9852d6f900b1998d974fef04">isVector</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a1ba5e10b9852d6f900b1998d974fef04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is a vector type.  <a href="#a1ba5e10b9852d6f900b1998d974fef04">More...</a><br /></td></tr>
<tr class="separator:a1ba5e10b9852d6f900b1998d974fef04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e4ef028c30b981759878dcf3202a75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a86e4ef028c30b981759878dcf3202a75">isFloatingPoint</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a86e4ef028c30b981759878dcf3202a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is a floating point type.  <a href="#a86e4ef028c30b981759878dcf3202a75">More...</a><br /></td></tr>
<tr class="separator:a86e4ef028c30b981759878dcf3202a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6326cd3db5c72ce757d0fdc4fd30d21d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6326cd3db5c72ce757d0fdc4fd30d21d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a6326cd3db5c72ce757d0fdc4fd30d21d">isFloatingPoint</a> ()</td></tr>
<tr class="memdesc:a6326cd3db5c72ce757d0fdc4fd30d21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a type is a floating point type.  <a href="#a6326cd3db5c72ce757d0fdc4fd30d21d">More...</a><br /></td></tr>
<tr class="separator:a6326cd3db5c72ce757d0fdc4fd30d21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf606f8f4e4e97426f3dd4e3d662ff"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a17bf606f8f4e4e97426f3dd4e3d662ff">isInteger</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a17bf606f8f4e4e97426f3dd4e3d662ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is an integer type.  <a href="#a17bf606f8f4e4e97426f3dd4e3d662ff">More...</a><br /></td></tr>
<tr class="separator:a17bf606f8f4e4e97426f3dd4e3d662ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122aded2200302833a428f731a8841df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a122aded2200302833a428f731a8841df"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a122aded2200302833a428f731a8841df">isInteger</a> ()</td></tr>
<tr class="memdesc:a122aded2200302833a428f731a8841df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a type is an integer type.  <a href="#a122aded2200302833a428f731a8841df">More...</a><br /></td></tr>
<tr class="separator:a122aded2200302833a428f731a8841df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0c5a7cd758d4f0e2495639da8496a3"><td class="memTemplParams" colspan="2">template&lt;typename T_FP &gt; </td></tr>
<tr class="memitem:a1e0c5a7cd758d4f0e2495639da8496a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a1e0c5a7cd758d4f0e2495639da8496a3">isSameFloatingPoint</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:a1e0c5a7cd758d4f0e2495639da8496a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is equivalent to a floating point type.  <a href="#a1e0c5a7cd758d4f0e2495639da8496a3">More...</a><br /></td></tr>
<tr class="separator:a1e0c5a7cd758d4f0e2495639da8496a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1011a1acfc03c4914f0a6e2d3443a9"><td class="memTemplParams" colspan="2">template&lt;typename T_Int &gt; </td></tr>
<tr class="memitem:aae1011a1acfc03c4914f0a6e2d3443a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#aae1011a1acfc03c4914f0a6e2d3443a9">isSameInteger</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> d)</td></tr>
<tr class="memdesc:aae1011a1acfc03c4914f0a6e2d3443a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if a Datatype is equivalent to an integer type.  <a href="#aae1011a1acfc03c4914f0a6e2d3443a9">More...</a><br /></td></tr>
<tr class="separator:aae1011a1acfc03c4914f0a6e2d3443a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97abc0c52f6828a3ce8f8a01bdd4a9fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a97abc0c52f6828a3ce8f8a01bdd4a9fe">isSame</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const d, <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const e)</td></tr>
<tr class="memdesc:a97abc0c52f6828a3ce8f8a01bdd4a9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for two Datatypes.  <a href="#a97abc0c52f6828a3ce8f8a01bdd4a9fe">More...</a><br /></td></tr>
<tr class="separator:a97abc0c52f6828a3ce8f8a01bdd4a9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05dafd6fa73486c900b54c67a6358f7"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType  = void, typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:aa05dafd6fa73486c900b54c67a6358f7"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#aa05dafd6fa73486c900b54c67a6358f7">switchType</a> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dt, Action action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa05dafd6fa73486c900b54c67a6358f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> datatype.  <a href="#aa05dafd6fa73486c900b54c67a6358f7">More...</a><br /></td></tr>
<tr class="separator:aa05dafd6fa73486c900b54c67a6358f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb09589bae9322698f52d7b154ecb3cc"><td class="memItemLeft" align="right" valign="top"><a id="adb09589bae9322698f52d7b154ecb3cc"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getBP1Extent</b> (Extent const &amp;e, std::string const &amp;delimiter=&quot;,&quot;)</td></tr>
<tr class="separator:adb09589bae9322698f52d7b154ecb3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e737b753dd80f3eb1c5822a2f5a63a5"><td class="memItemLeft" align="right" valign="top"><a id="a2e737b753dd80f3eb1c5822a2f5a63a5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getZerosLikeBP1Extent</b> (Extent const &amp;e, std::string const &amp;delimiter=&quot;,&quot;)</td></tr>
<tr class="separator:a2e737b753dd80f3eb1c5822a2f5a63a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bbaca4627cc9cfcbab78e18fd7bbde"><td class="memItemLeft" align="right" valign="top"><a id="aa4bbaca4627cc9cfcbab78e18fd7bbde"></a>
ADIOS_DATATYPES&#160;</td><td class="memItemRight" valign="bottom"><b>getBP1DataType</b> (<a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> dtype)</td></tr>
<tr class="separator:aa4bbaca4627cc9cfcbab78e18fd7bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32c080169685fa169a06aafbc23aadb"><td class="memItemLeft" align="right" valign="top"><a id="ad32c080169685fa169a06aafbc23aadb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>concrete_bp1_file_position</b> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *w)</td></tr>
<tr class="separator:ad32c080169685fa169a06aafbc23aadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b1a1f1944dbc9db5c83d53c667cede"><td class="memItemLeft" align="right" valign="top"><a id="a36b1a1f1944dbc9db5c83d53c667cede"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getEnvNum</b> (std::string const &amp;key, std::string const &amp;defaultValue)</td></tr>
<tr class="separator:a36b1a1f1944dbc9db5c83d53c667cede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d28f48bf5c1b808c96133fea83f68b7"><td class="memTemplParams" colspan="2"><a id="a7d28f48bf5c1b808c96133fea83f68b7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d28f48bf5c1b808c96133fea83f68b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readVectorAttributeInternal</b> (void *data, int size)</td></tr>
<tr class="separator:a7d28f48bf5c1b808c96133fea83f68b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63daebf76668c3627ddeb12ee730f10c"><td class="memItemLeft" align="right" valign="top"><a id="a63daebf76668c3627ddeb12ee730f10c"></a>
hid_t&#160;</td><td class="memItemRight" valign="bottom"><b>getH5DataType</b> (<a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a> const &amp;att)</td></tr>
<tr class="separator:a63daebf76668c3627ddeb12ee730f10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add284089e173436073305642d4312c94"><td class="memItemLeft" align="right" valign="top"><a id="add284089e173436073305642d4312c94"></a>
hid_t&#160;</td><td class="memItemRight" valign="bottom"><b>getH5DataSpace</b> (<a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a> const &amp;att)</td></tr>
<tr class="separator:add284089e173436073305642d4312c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1858f75fc1ed5f79bda91afeaac81ab1"><td class="memItemLeft" align="right" valign="top"><a id="a1858f75fc1ed5f79bda91afeaac81ab1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>concrete_h5_file_position</b> (<a class="el" href="classopen_p_m_d_1_1_writable.html">Writable</a> *w)</td></tr>
<tr class="separator:a1858f75fc1ed5f79bda91afeaac81ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5064c76f963a45e0ed2d3796e7a35b"><td class="memItemLeft" align="right" valign="top"><a id="aaa5064c76f963a45e0ed2d3796e7a35b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="namespaceopen_p_m_d.html#a836aa9398502263fb423787947bf4ff8">openPMD::IterationEncoding</a> const &amp;)</td></tr>
<tr class="separator:aaa5064c76f963a45e0ed2d3796e7a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77c87539e6b53bef7d3afb70347c076"><td class="memItemLeft" align="right" valign="top"><a id="af77c87539e6b53bef7d3afb70347c076"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="classopen_p_m_d_1_1_mesh.html#acee3512164b9df9b3549bac0aa782383">openPMD::Mesh::Geometry</a> const &amp;)</td></tr>
<tr class="separator:af77c87539e6b53bef7d3afb70347c076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb8fe26a6fd94fced4f5e493eee1486"><td class="memItemLeft" align="right" valign="top"><a id="a8bb8fe26a6fd94fced4f5e493eee1486"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="classopen_p_m_d_1_1_mesh.html#af28bf48368071545c77bb981b8c89009">openPMD::Mesh::DataOrder</a> const &amp;)</td></tr>
<tr class="separator:a8bb8fe26a6fd94fced4f5e493eee1486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684c17f1fdd0f9d04e1a92aa0efc52cf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a684c17f1fdd0f9d04e1a92aa0efc52cf">getVersion</a> ()</td></tr>
<tr class="memdesc:a684c17f1fdd0f9d04e1a92aa0efc52cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the version of the openPMD-api library (run-time)  <a href="#a684c17f1fdd0f9d04e1a92aa0efc52cf">More...</a><br /></td></tr>
<tr class="separator:a684c17f1fdd0f9d04e1a92aa0efc52cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f8b29a6c7b24f34c2383080bc325bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#af3f8b29a6c7b24f34c2383080bc325bc">getStandard</a> ()</td></tr>
<tr class="memdesc:af3f8b29a6c7b24f34c2383080bc325bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum supported version of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> standard (read &amp; write, run-time)  <a href="#af3f8b29a6c7b24f34c2383080bc325bc">More...</a><br /></td></tr>
<tr class="separator:af3f8b29a6c7b24f34c2383080bc325bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa97da38a96cab56c67724443cf6378"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#acfa97da38a96cab56c67724443cf6378">getStandardMinimum</a> ()</td></tr>
<tr class="memdesc:acfa97da38a96cab56c67724443cf6378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum supported version of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> standard (read, run-time)  <a href="#acfa97da38a96cab56c67724443cf6378">More...</a><br /></td></tr>
<tr class="separator:acfa97da38a96cab56c67724443cf6378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad291085916d366b26abe1c66ac6504e5"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#ad291085916d366b26abe1c66ac6504e5">getVariants</a> ()</td></tr>
<tr class="memdesc:ad291085916d366b26abe1c66ac6504e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the feature variants of the openPMD-api library (run-time)  <a href="#ad291085916d366b26abe1c66ac6504e5">More...</a><br /></td></tr>
<tr class="separator:ad291085916d366b26abe1c66ac6504e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae1a884049992feb89041c2e3f34e25cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1a884049992feb89041c2e3f34e25cb"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#ae1a884049992feb89041c2e3f34e25cb">shareRaw</a> (T *x)</td></tr>
<tr class="memdesc:ae1a884049992feb89041c2e3f34e25cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share ownership with a raw pointer.  <a href="#ae1a884049992feb89041c2e3f34e25cb">More...</a><br /></td></tr>
<tr class="separator:ae1a884049992feb89041c2e3f34e25cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1af44e59b50b255839dc102df941849"><td class="memTemplParams" colspan="2"><a id="ad1af44e59b50b255839dc102df941849"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1af44e59b50b255839dc102df941849"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T const &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shareRaw</b> (T const *x)</td></tr>
<tr class="separator:ad1af44e59b50b255839dc102df941849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5ebeab5c745c064a1d428e6d1eb003"><td class="memTemplParams" colspan="2"><a id="acf5ebeab5c745c064a1d428e6d1eb003"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf5ebeab5c745c064a1d428e6d1eb003"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shareRaw</b> (T &amp;c) -&gt; std::shared_ptr&lt; typename std::remove_pointer&lt; decltype(c.data()) &gt;::type &gt;</td></tr>
<tr class="separator:acf5ebeab5c745c064a1d428e6d1eb003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078bdf44a6b27e3b5d1c8cec49abdc5a"><td class="memTemplParams" colspan="2"><a id="a078bdf44a6b27e3b5d1c8cec49abdc5a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a078bdf44a6b27e3b5d1c8cec49abdc5a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shareRaw</b> (T const &amp;c) -&gt; std::shared_ptr&lt; typename std::remove_pointer&lt; decltype(c.data()) &gt;::type &gt;</td></tr>
<tr class="separator:a078bdf44a6b27e3b5d1c8cec49abdc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a276c2fa9e763d9c53ae30f3cadf3d317"><td class="memItemLeft" align="right" valign="top"><a id="a276c2fa9e763d9c53ae30f3cadf3d317"></a>
std::vector&lt; <a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen_p_m_d.html#a276c2fa9e763d9c53ae30f3cadf3d317">openPMD_Datatypes</a></td></tr>
<tr class="memdesc:a276c2fa9e763d9c53ae30f3cadf3d317"><td class="mdescLeft">&#160;</td><td class="mdescRight">All <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> datatypes defined in Datatype, listed in order in a vector. <br /></td></tr>
<tr class="separator:a276c2fa9e763d9c53ae30f3cadf3d317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public definitions of openPMD-api. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afe5e394ac0a898c858a43b60913d46ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5e394ac0a898c858a43b60913d46ad">&#9670;&nbsp;</a></span>AccessType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46ad">openPMD::AccessType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structopen_p_m_d_1_1_file.html">File</a> access mode to use during IO. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afe5e394ac0a898c858a43b60913d46ada47c7e7cb36a953a8c47e02000036bb44"></a>READ_ONLY&#160;</td><td class="fielddoc"><p>open series as read-only, fails if series is not found </p>
</td></tr>
<tr><td class="fieldname"><a id="afe5e394ac0a898c858a43b60913d46adaa7b843fb734e3b3fea8e5f902d3f4144"></a>READ_WRITE&#160;</td><td class="fielddoc"><p>open existing series as writable </p>
</td></tr>
<tr><td class="fieldname"><a id="afe5e394ac0a898c858a43b60913d46ada294ce20cdefa29be3be0735cb62e715d"></a>CREATE&#160;</td><td class="fielddoc"><p>create new series and truncate existing (files) </p>
</td></tr>
</table>

</div>
</div>
<a id="a836aa9398502263fb423787947bf4ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836aa9398502263fb423787947bf4ff8">&#9670;&nbsp;</a></span>IterationEncoding</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#a836aa9398502263fb423787947bf4ff8">openPMD::IterationEncoding</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encoding scheme of an Iterations <a class="el" href="classopen_p_m_d_1_1_series.html" title="Root level of the openPMD hierarchy. ">Series</a>'. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/openPMD/openPMD-standard/blob/latest/STANDARD.md#iterations-and-time-series">https://github.com/openPMD/openPMD-standard/blob/latest/STANDARD.md#iterations-and-time-series</a> </dd></dl>

</div>
</div>
<a id="a5bd35872ff3aaacc1ec2700443d89c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd35872ff3aaacc1ec2700443d89c40">&#9670;&nbsp;</a></span>UnitDimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen_p_m_d.html#a5bd35872ff3aaacc1ec2700443d89c40">openPMD::UnitDimension</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Physical dimension of a record. </p>
<p>Dimensional base quantities of the international system of quantities </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40ad20caec3b48a1eef164cb4ca81ba2587"></a>L&#160;</td><td class="fielddoc"><p>length </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40a69691c7bdcc3ce6d5d8a1361f22d04ac"></a>M&#160;</td><td class="fielddoc"><p>mass </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40ab9ece18c950afbfa6b0fdbfa4ff731d3"></a>T&#160;</td><td class="fielddoc"><p>time </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40add7536794b63bf90eccfd37f9b147d7f"></a>I&#160;</td><td class="fielddoc"><p>electric current </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40a61a74be60d291cc4678ab46cc1cdaf91"></a>theta&#160;</td><td class="fielddoc"><p>thermodynamic temperature </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40a8d9c307cb7f3c4a32822a51922d1ceaa"></a>N&#160;</td><td class="fielddoc"><p>amount of substance </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bd35872ff3aaacc1ec2700443d89c40aff44570aca8241914870afbc310cdb85"></a>J&#160;</td><td class="fielddoc"><p>luminous intensity </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aed98a0d6afbbfda7c19c6917fc7ab411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed98a0d6afbbfda7c19c6917fc7ab411">&#9670;&nbsp;</a></span>basicDatatype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a> openPMD::basicDatatype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>basicDatatype Strip <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> Datatype of std::vector, std::array et. </p>
<p>al. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The "full" Datatype. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The "inner" Datatype. </dd></dl>

</div>
</div>
<a id="a464eb3d415d7da00a7e271968f7aa69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464eb3d415d7da00a7e271968f7aa69c">&#9670;&nbsp;</a></span>cleanFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::cleanFilename </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the filename extension of a given storage format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>String containing the filename, possibly with filename extension. </td></tr>
    <tr><td class="paramname">f</td><td><a class="el" href="structopen_p_m_d_1_1_file.html">File</a> format to remove filename extension for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the filename without filename extension. </dd></dl>

</div>
</div>
<a id="a31cda7efef783c0accdbf3097ff698c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cda7efef783c0accdbf3097ff698c7">&#9670;&nbsp;</a></span>createIOHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt; openPMD::createIOHandler </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46ad">AccessType</a>&#160;</td>
          <td class="paramname"><em>accessType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an appropriate specific IOHandler for the desired IO mode that may be MPI-aware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to root folder for all operations associated with the desired handler. </td></tr>
    <tr><td class="paramname">accessType</td><td>AccessType describing desired operations and permissions of the desired handler. </td></tr>
    <tr><td class="paramname">format</td><td>Format describing the IO backend of the desired handler. </td></tr>
    <tr><td class="paramname">comm</td><td>MPI communicator used for IO. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to created IOHandler. </dd></dl>

</div>
</div>
<a id="adacd154a6a5324e315942f5d9355a9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacd154a6a5324e315942f5d9355a9ee">&#9670;&nbsp;</a></span>createIOHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen_p_m_d_1_1_abstract_i_o_handler.html">AbstractIOHandler</a> &gt; openPMD::createIOHandler </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#afe5e394ac0a898c858a43b60913d46ad">AccessType</a>&#160;</td>
          <td class="paramname"><em>accessType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an appropriate specific IOHandler for the desired IO mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to root folder for all operations associated with the desired handler. </td></tr>
    <tr><td class="paramname">accessType</td><td>AccessType describing desired operations and permissions of the desired handler. </td></tr>
    <tr><td class="paramname">format</td><td>Format describing the IO backend of the desired handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to created IOHandler. </dd></dl>

</div>
</div>
<a id="adae7debe2cfe5e72fa62c26e265da442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae7debe2cfe5e72fa62c26e265da442">&#9670;&nbsp;</a></span>determineFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a> openPMD::determineFormat </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the storage format of a <a class="el" href="classopen_p_m_d_1_1_series.html" title="Root level of the openPMD hierarchy. ">Series</a> from the used filename extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>string containing the filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Format that best fits the filename extension. </dd></dl>

</div>
</div>
<a id="a9302b24b95911d3524d0539cf71bcac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9302b24b95911d3524d0539cf71bcac0">&#9670;&nbsp;</a></span>getCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U openPMD::getCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen_p_m_d_1_1_attribute.html">Attribute</a> const &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a stored specific <a class="el" href="classopen_p_m_d_1_1_attribute.html" title="Varidic datatype supporting at least all formats for attributes specified in the openPMD standard...">Attribute</a> and cast if convertible. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if stored object is not static castable to U. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Type of the object to be casted to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the retrieved object, casted to type U. </dd></dl>

</div>
</div>
<a id="af3f8b29a6c7b24f34c2383080bc325bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f8b29a6c7b24f34c2383080bc325bc">&#9670;&nbsp;</a></span>getStandard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::getStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum supported version of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> standard (read &amp; write, run-time) </p>
<dl class="section return"><dt>Returns</dt><dd>std::string <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> standard version (dot separated) </dd></dl>

</div>
</div>
<a id="acfa97da38a96cab56c67724443cf6378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa97da38a96cab56c67724443cf6378">&#9670;&nbsp;</a></span>getStandardMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::getStandardMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum supported version of the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> standard (read, run-time) </p>
<dl class="section return"><dt>Returns</dt><dd>std::string minimum <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> standard version (dot separated) </dd></dl>

</div>
</div>
<a id="ad291085916d366b26abe1c66ac6504e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad291085916d366b26abe1c66ac6504e5">&#9670;&nbsp;</a></span>getVariants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, bool &gt; openPMD::getVariants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the feature variants of the openPMD-api library (run-time) </p>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt; std::string, bool &gt; with variants such as backends </dd></dl>

</div>
</div>
<a id="a684c17f1fdd0f9d04e1a92aa0efc52cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684c17f1fdd0f9d04e1a92aa0efc52cf">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the version of the openPMD-api library (run-time) </p>
<dl class="section return"><dt>Returns</dt><dd>std::string API version (dot separated) </dd></dl>

</div>
</div>
<a id="a86e4ef028c30b981759878dcf3202a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e4ef028c30b981759878dcf3202a75">&#9670;&nbsp;</a></span>isFloatingPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isFloatingPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is a floating point type. </p>
<p>Equivalent to std::is_floating_point including our vector types</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if floating point, otherwise false </dd></dl>

</div>
</div>
<a id="a6326cd3db5c72ce757d0fdc4fd30d21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6326cd3db5c72ce757d0fdc4fd30d21d">&#9670;&nbsp;</a></span>isFloatingPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isFloatingPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a type is a floating point type. </p>
<p>Just std::is_floating_point but also valid for std::vector&lt; &gt; types</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if floating point, otherwise false </dd></dl>

</div>
</div>
<a id="a17bf606f8f4e4e97426f3dd4e3d662ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bf606f8f4e4e97426f3dd4e3d662ff">&#9670;&nbsp;</a></span>isInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, bool &gt; openPMD::isInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is an integer type. </p>
<p>contrary to std::is_integer, the types bool and char types are not considered ints in this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;bool, bool&gt; with isInteger and isSigned result </dd></dl>

</div>
</div>
<a id="a122aded2200302833a428f731a8841df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122aded2200302833a428f731a8841df">&#9670;&nbsp;</a></span>isInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, bool &gt; openPMD::isInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a type is an integer type. </p>
<p>contrary to std::is_integer, the types bool and char types are not considered ints in this function</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;bool, bool&gt; with isInteger and isSigned result </dd></dl>

</div>
</div>
<a id="a97abc0c52f6828a3ce8f8a01bdd4a9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97abc0c52f6828a3ce8f8a01bdd4a9fe">&#9670;&nbsp;</a></span>isSame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isSame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">openPMD::Datatype</a> const&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison for two Datatypes. </p>
<p>Besides returning true for the same types, identical implementations on some platforms, e.g. if long and long long are the same or double and long double will also return true. </p>

</div>
</div>
<a id="a1e0c5a7cd758d4f0e2495639da8496a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0c5a7cd758d4f0e2495639da8496a3">&#9670;&nbsp;</a></span>isSameFloatingPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_FP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isSameFloatingPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is equivalent to a floating point type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_FP</td><td>floating point type to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both types are floating point and same bitness, else false </dd></dl>

</div>
</div>
<a id="aae1011a1acfc03c4914f0a6e2d3443a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1011a1acfc03c4914f0a6e2d3443a9">&#9670;&nbsp;</a></span>isSameInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isSameInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is equivalent to an integer type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_Int</td><td>signed or unsigned integer type to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both types are integers, same signed and same bitness, else false </dd></dl>

</div>
</div>
<a id="a1ba5e10b9852d6f900b1998d974fef04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba5e10b9852d6f900b1998d974fef04">&#9670;&nbsp;</a></span>isVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openPMD::isVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if a Datatype is a vector type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if vector type, else false </dd></dl>

</div>
</div>
<a id="ab71d9ef7c9f67b687c9e1b4b10f2519f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71d9ef7c9f67b687c9e1b4b10f2519f">&#9670;&nbsp;</a></span>matcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; std::tuple&lt; bool, int &gt;std::string const  &amp;) &gt; openPMD::matcher </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>postfix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a functor to determine if a file can be of a format and matches an iterationEncoding, given the filename on disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>String containing head (i.e. before T) of desired filename without filename extension. </td></tr>
    <tr><td class="paramname">padding</td><td>Amount of padding allowed in iteration number T. If zero, any amount of padding is matched. </td></tr>
    <tr><td class="paramname">postfix</td><td>String containing tail (i.e. after T) of desired filename without filename extension. </td></tr>
    <tr><td class="paramname">f</td><td><a class="el" href="structopen_p_m_d_1_1_file.html">File</a> format to check backend applicability for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor returning tuple of bool and int. bool is True if file could be of type f and matches the iterationEncoding. False otherwise. int is the amount of padding present in the iteration number T. Is 0 if bool is False. </dd></dl>

</div>
</div>
<a id="ae1a884049992feb89041c2e3f34e25cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a884049992feb89041c2e3f34e25cb">&#9670;&nbsp;</a></span>shareRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; openPMD::shareRaw </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Share ownership with a raw pointer. </p>
<p>Helper function to share load/store data ownership unprotected and without reference counting with a raw pointer or stdlib container (that implements a contiguous data storage).</p>
<dl class="section warning"><dt>Warning</dt><dd>this is a helper function to bypass the shared-pointer API for storing data behind raw pointers. Using it puts the responsibility of buffer-consistency between stores and flushes to the users side without an indication via reference counting. </dd></dl>

</div>
</div>
<a id="ae85ac121e561aace5e433173de458068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85ac121e561aace5e433173de458068">&#9670;&nbsp;</a></span>suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string openPMD::suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#a7dc2b05c997920a65ff9297e52f3286d">Format</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the default filename suffix for a given storage format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td><a class="el" href="structopen_p_m_d_1_1_file.html">File</a> format to determine suffix for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the default filename suffix </dd></dl>

</div>
</div>
<a id="aa05dafd6fa73486c900b54c67a6358f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05dafd6fa73486c900b54c67a6358f7">&#9670;&nbsp;</a></span>switchType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType  = void, typename Action , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType openPMD::switchType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalizes switching over an <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> datatype. </p>
<p>Will call the functor passed to it using the C++ internal datatype corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> datatype as template parameter for the templated &lt;operator()&gt;().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReturnType</td><td>The functor's return type. </td></tr>
    <tr><td class="paramname">Action</td><td>The functor's type. </td></tr>
    <tr><td class="paramname">Args</td><td>The functors argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> datatype. </td></tr>
    <tr><td class="paramname">action</td><td>The functor. </td></tr>
    <tr><td class="paramname">args</td><td>The functor's arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the functor, when calling its &lt;operator()&gt;() with the passed arguments and the template parameter type corresponding to the <a class="el" href="namespaceopen_p_m_d.html" title="Public definitions of openPMD-api. ">openPMD</a> type. </dd></dl>

</div>
</div>
<a id="a31ccc9b338d37af8c6bbbcf4f53dfeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ccc9b338d37af8c6bbbcf4f53dfeee">&#9670;&nbsp;</a></span>toBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t openPMD::toBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bits representing a Datatype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bits </dd></dl>

</div>
</div>
<a id="a9b670ad71d6e80073a7d8fb689b1fd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b670ad71d6e80073a7d8fb689b1fd4a">&#9670;&nbsp;</a></span>toBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t openPMD::toBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopen_p_m_d.html#ac04f58bb14b584a3685793e5b29ccd00">Datatype</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bytes representing a Datatype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Datatype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
